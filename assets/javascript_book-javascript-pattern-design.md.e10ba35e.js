import{o as n,c as s,d as a}from"./app.d7e7aadc.js";const p='{"title":"《Javascript 设计模式与开发实战》","description":"","frontmatter":{"title":"《Javascript 设计模式与开发实战》"},"headers":[{"level":2,"title":"第 1 章","slug":"第-1-章"}],"relativePath":"javascript/book-javascript-pattern-design.md","lastUpdated":1620227023151}',t={},o=a('<h2 id="第-1-章"><a class="header-anchor" href="#第-1-章" aria-hidden="true">#</a> 第 1 章</h2><p>JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象 与对象之间的继承。JavaScript 也没有在语言层面提供对抽象类和接口的支持。</p><p>1.1</p><p>编程语言按照数据类型大体可以分为两类，一类是静态类型语言，另一类是动态类型语言。 静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时 候，待变量被赋予某个值之后，才会具有某种类型。</p><p>静态类型语言的优点首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前 避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译 器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度。</p><div class="tip custom-block"><p class="custom-block-title">💡</p><p>js 也能写出严谨的代码，不过得多写 <code>if (obj.fn &amp;&amp; typeof obj.fn === &#39;function&#39;)</code> 这类代码...</p></div><p>静态类型语言的缺点首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型， 归根结底只是辅助我们编写可靠性高程序的一种手段，而不是编写程序的目的，毕竟大部分人编 写程序的目的是为了完成需求交付生产。其次，类型的声明也会增加更多的代码，在程序编写过 程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。</p><p>动态类型语言的优点是编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地 放在业务逻辑上面。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量 越少，越专注于逻辑表达，对阅读程序是越有帮助的。</p><p>动态类型语言的缺点是无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的 错误。这好像在商店买了一包牛肉辣条，但是要真正吃到嘴里才知道是不是牛肉味。</p><p>在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们 不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是 面向实现编程”。例如，一个对象若有 push 和 pop 方法，并且这些方法提供了正确的实现，它就 可以被当作栈来使用。一个对象如果有 length 属性，也可以依照下标来存取属性（最好还要拥 有 slice 和 splice 等方法），这个对象就可以被当作数组来使用。</p><p>1.2</p><p>多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结 果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的 反馈。</p><div class="language-js"><pre><code><span class="token comment">// 实现多态 😭</span>\n<span class="token keyword">var</span> <span class="token function-variable function">makeSound</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">animal</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>\n <span class="token keyword">if</span> <span class="token punctuation">(</span> animal <span class="token keyword">instanceof</span> <span class="token class-name">Duck</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>\n console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&#39;嘎嘎嘎&#39;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>\n <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> animal <span class="token keyword">instanceof</span> <span class="token class-name">Chicken</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>\n console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&#39;咯咯咯&#39;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>\n <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> <span class="token function-variable function">Duck</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> <span class="token function-variable function">Chicken</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token function">makeSound</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">Duck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 嘎嘎嘎</span>\n<span class="token function">makeSound</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">Chicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 咯咯咯</span>\n</code></pre></div><p>多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事 物”与 “可能改变的事物”分离开来。在这个故事中，动物都会叫，这是不变的，但是不同类 型的动物具体怎么叫是可变的。把不变的部分隔离出来，把可变的部分封装起来，这给予了我们 扩展程序的能力，程序看起来是可生长的，也是符合开放—封闭</p><p>1.2.4</p><p>使用继承来得到多态效果，是让对象表现出多态性的最常用手段。继承通常包括实现继承和 接口继承。</p><p>而 JavaScript 的变量类型在运行期是可变的。一个 JavaScript 对象，既可以表示 Duck 类型的 对象，又可以表示 Chicken 类型的对象，这意味着 JavaScript 对象的多态性是与生俱来的。</p><p>换句话说，多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而 消除这些条件分支语句。</p><div class="language-js"><pre><code><span class="token keyword">var</span> <span class="token function-variable function">makeSound</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">animal</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>\n animal<span class="token punctuation">.</span><span class="token function">sound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> <span class="token function-variable function">Duck</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token class-name">Duck</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sound</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&#39;嘎嘎嘎&#39;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> <span class="token function-variable function">Chicken</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token class-name">Chicken</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sound</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">&#39;咯咯咯&#39;</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token function">makeSound</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">Duck</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 嘎嘎嘎</span>\n<span class="token function">makeSound</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">Chicken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 咯咯咯</span>\n</code></pre></div><p>1.3 封装</p><p>封装的目的是将信息隐藏。一般而言，我们讨论的封装是封装数据和封装实现。这一节将讨 论更广义的封装，不仅包括封装数据和封装实现，还包括封装类型和封装变化。</p><p>在许多语言的对象系统中，封装数据是由语法解析来实现的，这些语言也许提供了 private、 public、protected 等关键字来提供不同的访问权限。 但 JavaScript 并没有提供对这些关键字的支持，我们只能依赖变量的作用域来实现封装特性， 而且只能模拟出 public 和 private 这两种封装性。</p><div class="language-js"><pre><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token keyword">var</span> __name <span class="token operator">=</span> <span class="token string">&#39;sven&#39;</span><span class="token punctuation">;</span> <span class="token comment">// 私有（private）变量</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">getName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 公开（public）方法</span>\n      <span class="token keyword">return</span> __name<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>还可以通过 Symbol 创建私有属性。</p><p>封装的目的是将信息隐藏，封装应该被视为“任何形式的封装”，也就是说，封装不仅仅是 隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。</p><p>封装使得对象之间的耦合变松散，对象之间只通过暴露的 API 接口来通信。当我们修改一个对象时，可以随意地修改它的 内部实现，只要对外的接口没有变化，就不会影响到程序的其他功能。</p><p>1.4.1 使用克隆的原型模式</p><p>原型模式的实现关键，是语言本身是否提供了clone方法。ECMAScript 5提供了Object.create 方法，可以用来克隆对象。</p><p>但原型模式的真正目的并非在于需要得到一个一模一样的对象，而是提供了一种便捷的方式去创建某个类 型的对象，克隆只是创建这个对象的过程和手段。</p><p>基于原型链的委托机制就是原型继承的本质。 现在我们明白了原型编程中的一个重要特性，即当对象无法响应某个请求时，会把该请求委 托给它自己的原型。</p><p>总结</p><p>最后整理一下本节的描述，我们可以发现原型编程范型至少包括以下基本规则。</p><ul><li>所有的数据都是对象。</li><li>要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。</li><li>对象会记住它的原型。</li><li>如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。</li></ul><p>事实上，JavaScript 中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空的 对象。我们在 JavaScript 遇到的每个对象，实际上都是从 Object.prototype 对象克隆而来的， Object.prototype 对象就是它们的原型。</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span> <span class="token parameter">name</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>\n <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span> <span class="token string">&#39;sven&#39;</span> <span class="token punctuation">)</span>\n</code></pre></div><p>在这里 Person 并不是类，而是函数构造器，JavaScript 的函数既可以作为普通函数被调用， 也可以作为构造器被调用。当使用 new 运算符来调用函数时，此时的函数就是一个构造器。 用 new 运算符来创建对象的过程，实际上也只是先克隆 Object.prototype 对象，再进行一些其他额 外操作的过程。</p><p>目前我们一直在讨论“对象的原型”，就 JavaScript 的真正实现来说，其实并不能说对象有 原型，而只能说对象的构造器有原型。对于“对象把请求委托给它自己的原型”这句话，更好 的说法是对象把请求委托给它的构造器的原型。</p>',37);t.render=function(a,p,t,c,e,u){return n(),s("div",null,[o])};export default t;export{p as __pageData};
